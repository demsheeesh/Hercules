diff a/src/map/skill.c b/src/map/skill.c	(rejected hunks)
@@ -2692,7 +2692,7 @@ int skill_attack(int attack_type, struct block_list* src, struct block_list *dsr
 	if( !dmg.amotion ) {
 		//Instant damage
 		if( (!sc || (!sc->data[SC_DEVOTION] && skill_id != CR_REFLECTSHIELD)) && !shadow_flag)
-			status_fix_damage(src,bl,damage,dmg.dmotion); //Deal damage before knockback to allow stuff like firewall+storm gust combo.
+			status_fix_damage(src,bl,damage,dmg.dmotion, skill_id); //Deal damage before knockback to allow stuff like firewall+storm gust combo.
 		if( !status->isdead(bl) && additional_effects )
 			skill->additional_effect(src,bl,skill_id,skill_lv,dmg.flag,dmg.dmg_lv,tick);
 		if( damage > 0 ) //Counter status effects [Skotlex]
@@ -2783,18 +2783,18 @@ int skill_attack(int attack_type, struct block_list* src, struct block_list *dsr
 		) {
 			if(!rmdamage){
 				clif->damage(d_bl,d_bl, 0, 0, damage, 0, BDT_NORMAL, 0);
-				status_fix_damage(NULL,d_bl, damage, 0);
+				status_fix_damage(NULL,d_bl, damage, 0, 0);
 			} else{ //Reflected magics are done directly on the target not on paladin
 				//This check is only for magical skill.
 				//For BF_WEAPON skills types track var rdamage and function battle_calc_return_damage
 				clif->damage(bl,bl, 0, 0, damage, 0, BDT_NORMAL, 0);
-				status_fix_damage(bl,bl, damage, 0);
+				status_fix_damage(bl,bl, damage, 0, 0);
 			}
 		}
 		else {
 			status_change_end(bl, SC_DEVOTION, INVALID_TIMER);
 			if( !dmg.amotion )
-				status_fix_damage(src,bl,damage,dmg.dmotion);
+				status_fix_damage(src,bl,damage,dmg.dmotion, 0);
 		}
 	}
 
@@ -5457,6 +5457,17 @@ int skill_castend_nodamage_id(struct block_list *src, struct block_list *bl, uin
 						heal_get_jobexp = 1;
 					pc->gainexp (sd, bl, 0, heal_get_jobexp, false);
 				}
+
+				if(sd && dstsd && heal > 0 && sd != dstsd)
+				{
+					if (sd->status.guild_id && map_allowed_woe(src->m))
+					{
+						if (sd->status.guild_id == dstsd->status.guild_id || guild_isallied(sd->status.guild_id, dstsd->status.guild_id))
+							 add2limit(sd->status.woe_statistics.healing_done, heal_get_jobexp, UINT_MAX);
+						else
+							 add2limit(sd->status.woe_statistics.wrong_healing_done, heal_get_jobexp, UINT_MAX);
+					}
+				}
 			}
 			break;
 
@@ -6664,7 +6675,7 @@ int skill_castend_nodamage_id(struct block_list *src, struct block_list *bl, uin
 		case MER_SCAPEGOAT:
 			if( mer && mer->master ) {
 				status->heal(&mer->master->bl, mer->battle_status.hp, 0, 2);
-				status->damage(src, src, mer->battle_status.max_hp, 0, 0, 1);
+				status->damage_(src, src, mer->battle_status.max_hp, 0, 0, 1, skill_id);
 			}
 			break;
 
@@ -7757,7 +7768,7 @@ int skill_castend_nodamage_id(struct block_list *src, struct block_list *bl, uin
 						break;
 					case 3: // 1000 damage, random armor destroyed
 						{
-							status_fix_damage(src, bl, 1000, 0);
+							status_fix_damage(src, bl, 1000, 0, skill_id);
 							clif->damage(src,bl,0,0,1000,0,BDT_NORMAL,0);
 							if( !status->isdead(bl) ) {
 								int where[] = { EQP_ARMOR, EQP_SHIELD, EQP_HELM, EQP_SHOES, EQP_GARMENT };
@@ -9876,6 +9887,17 @@ int skill_castend_nodamage_id(struct block_list *src, struct block_list *bl, uin
 			status_change_end(src,SC_CURSEDCIRCLE_ATKER,INVALID_TIMER);
 	}
 
+	if (skill_get_inf(skill_id)&INF_SUPPORT_SKILL && sd && dstsd && sd != dstsd)
+	{
+		if (map_allowed_woe(src->m) && sd->status.guild_id)
+		{
+			if (sd->status.guild_id == dstsd->status.guild_id || guild_isallied(sd->status.guild_id, dstsd->status.guild_id))
+				add2limit(sd->status.woe_statistics.support_skills_used, 1, UINT_MAX);
+			else
+				add2limit(sd->status.woe_statistics.wrong_support_skills_used, 1, UINT_MAX);
+		}
+	}
+
 	if (dstmd) { //Mob skill event for no damage skills (damage ones are handled in battle_calc_damage) [Skotlex]
 		mob->log_damage(dstmd, src, 0); //Log interaction (counts as 'attacker' for the exp bonus)
 		mob->skill_event(dstmd, src, tick, MSC_SKILLUSED|(skill_id<<16));
@@ -14292,8 +14314,12 @@ void skill_check_condition_castend_unknown(struct map_session_data* sd, uint16 *
 int skill_consume_requirement( struct map_session_data *sd, uint16 skill_id, uint16 skill_lv, short type) {
 	struct skill_condition req;
 
+	int rankFlag = 0;
 	nullpo_ret(sd);
 
+	if (map_allowed_woe(sd->bl.m) && sd->status.guild_id)
+		rankFlag = 1;
+
 	req = skill->get_requirement(sd,skill_id,skill_lv);
 
 	if (type&1) {
@@ -14311,8 +14337,20 @@ int skill_consume_requirement( struct map_session_data *sd, uint16 skill_id, uin
 		if(req.hp || req.sp)
 			status_zap(&sd->bl, req.hp, req.sp);
 
-		if(req.spiritball > 0)
-			pc->delspiritball(sd,req.spiritball,0);
+		if (req.sp)
+		{
+			if (rankFlag == 1)
+				add2limit(sd->status.woe_statistics.sp_used, req.sp, UINT_MAX);
+		}
+
+		if (req.spiritball > 0)
+		{
+			pc->delspiritball(sd, req.spiritball, 0);
+			if (rankFlag == 1)
+			{
+				add2limit(sd->status.woe_statistics.spiritb_used, req.spiritball, UINT_MAX);
+			}
+		}
 
 		if(req.zeny > 0)
 		{
